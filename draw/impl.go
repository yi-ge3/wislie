// generated by "go run gen.go". DO NOT EDIT.

package draw

import (
	"image"
	"image/color"
	"math"

	"golang.org/x/image/math/f64"
)

func (z nnInterpolator) Scale(dst Image, dr image.Rectangle, src image.Image, sr image.Rectangle, opts *Options) {
	// adr is the affected destination pixels, relative to dr.Min.
	adr := dst.Bounds().Intersect(dr).Sub(dr.Min)
	if adr.Empty() || sr.Empty() {
		return
	}
	// sr is the source pixels. If it extends beyond the src bounds,
	// we cannot use the type-specific fast paths, as they access
	// the Pix fields directly without bounds checking.
	if !sr.In(src.Bounds()) {
		z.scale_Image_Image(dst, dr, adr, src, sr)
	} else {
		switch dst := dst.(type) {
		case *image.RGBA:
			switch src := src.(type) {
			case *image.Gray:
				z.scale_RGBA_Gray(dst, dr, adr, src, sr)
			case *image.NRGBA:
				z.scale_RGBA_NRGBA(dst, dr, adr, src, sr)
			case *image.RGBA:
				z.scale_RGBA_RGBA(dst, dr, adr, src, sr)
			case *image.Uniform:
				z.scale_RGBA_Uniform(dst, dr, adr, src, sr)
			case *image.YCbCr:
				switch src.SubsampleRatio {
				default:
					z.scale_RGBA_Image(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio444:
					z.scale_RGBA_YCbCr444(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio422:
					z.scale_RGBA_YCbCr422(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio420:
					z.scale_RGBA_YCbCr420(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio440:
					z.scale_RGBA_YCbCr440(dst, dr, adr, src, sr)
				}
			default:
				z.scale_RGBA_Image(dst, dr, adr, src, sr)
			}
		default:
			switch src := src.(type) {
			default:
				z.scale_Image_Image(dst, dr, adr, src, sr)
			}
		}
	}
}

func (z nnInterpolator) Transform(dst Image, s2d *f64.Aff3, src image.Image, sr image.Rectangle, opts *Options) {
	dr := transformRect(s2d, &sr)
	// adr is the affected destination pixels, relative to dr.Min.
	adr := dst.Bounds().Intersect(dr).Sub(dr.Min)
	if adr.Empty() || sr.Empty() {
		return
	}
	d2s := invert(s2d)
	// sr is the source pixels. If it extends beyond the src bounds,
	// we cannot use the type-specific fast paths, as they access
	// the Pix fields directly without bounds checking.
	if !sr.In(src.Bounds()) {
		z.transform_Image_Image(dst, dr, adr, &d2s, src, sr)
	} else {
		switch dst := dst.(type) {
		case *image.RGBA:
			switch src := src.(type) {
			case *image.Gray:
				z.transform_RGBA_Gray(dst, dr, adr, &d2s, src, sr)
			case *image.NRGBA:
				z.transform_RGBA_NRGBA(dst, dr, adr, &d2s, src, sr)
			case *image.RGBA:
				z.transform_RGBA_RGBA(dst, dr, adr, &d2s, src, sr)
			case *image.Uniform:
				z.transform_RGBA_Uniform(dst, dr, adr, &d2s, src, sr)
			case *image.YCbCr:
				switch src.SubsampleRatio {
				default:
					z.transform_RGBA_Image(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio444:
					z.transform_RGBA_YCbCr444(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio422:
					z.transform_RGBA_YCbCr422(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio420:
					z.transform_RGBA_YCbCr420(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio440:
					z.transform_RGBA_YCbCr440(dst, dr, adr, &d2s, src, sr)
				}
			default:
				z.transform_RGBA_Image(dst, dr, adr, &d2s, src, sr)
			}
		default:
			switch src := src.(type) {
			default:
				z.transform_Image_Image(dst, dr, adr, &d2s, src, sr)
			}
		}
	}
}

func (nnInterpolator) scale_RGBA_Gray(dst *image.RGBA, dr, adr image.Rectangle, src *image.Gray, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.PixOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pr := uint32(src.Pix[pi]) * 0x101
			out := uint8(uint32(pr) >> 8)
			dst.Pix[d+0] = out
			dst.Pix[d+1] = out
			dst.Pix[d+2] = out
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) scale_RGBA_NRGBA(dst *image.RGBA, dr, adr image.Rectangle, src *image.NRGBA, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.PixOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pa := uint32(src.Pix[pi+3]) * 0x101
			pr := uint32(src.Pix[pi+0]) * pa / 0xff
			pg := uint32(src.Pix[pi+1]) * pa / 0xff
			pb := uint32(src.Pix[pi+2]) * pa / 0xff
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) scale_RGBA_RGBA(dst *image.RGBA, dr, adr image.Rectangle, src *image.RGBA, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.PixOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pr := uint32(src.Pix[pi+0]) * 0x101
			pg := uint32(src.Pix[pi+1]) * 0x101
			pb := uint32(src.Pix[pi+2]) * 0x101
			pa := uint32(src.Pix[pi+3]) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) scale_RGBA_Uniform(dst *image.RGBA, dr, adr image.Rectangle, src *image.Uniform, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pr, pg, pb, pa := src.At(sr.Min.X+int(sx), sr.Min.Y+int(sy)).RGBA()
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) scale_RGBA_YCbCr444(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.YOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pj := src.COffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) scale_RGBA_YCbCr422(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.YOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pj := src.COffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) scale_RGBA_YCbCr420(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.YOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pj := src.COffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) scale_RGBA_YCbCr440(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pi := src.YOffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pj := src.COffset(sr.Min.X+int(sx), sr.Min.Y+int(sy))
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) scale_RGBA_Image(dst *image.RGBA, dr, adr image.Rectangle, src image.Image, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pr, pg, pb, pa := src.At(sr.Min.X+int(sx), sr.Min.Y+int(sy)).RGBA()
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) scale_Image_Image(dst Image, dr, adr image.Rectangle, src image.Image, sr image.Rectangle) {
	dw2 := uint64(dr.Dx()) * 2
	dh2 := uint64(dr.Dy()) * 2
	sw := uint64(sr.Dx())
	sh := uint64(sr.Dy())
	dstColorRGBA64 := &color.RGBA64{}
	dstColor := color.Color(dstColorRGBA64)
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (2*uint64(dy) + 1) * sh / dh2
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
			sx := (2*uint64(dx) + 1) * sw / dw2
			pr, pg, pb, pa := src.At(sr.Min.X+int(sx), sr.Min.Y+int(sy)).RGBA()
			dstColorRGBA64.R = uint16(pr)
			dstColorRGBA64.G = uint16(pg)
			dstColorRGBA64.B = uint16(pb)
			dstColorRGBA64.A = uint16(pa)
			dst.Set(dr.Min.X+int(dx), dr.Min.Y+int(dy), dstColor)
		}
	}
}

func (nnInterpolator) transform_RGBA_Gray(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.Gray, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.PixOffset(sx0, sy0)
			pr := uint32(src.Pix[pi]) * 0x101
			out := uint8(uint32(pr) >> 8)
			dst.Pix[d+0] = out
			dst.Pix[d+1] = out
			dst.Pix[d+2] = out
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) transform_RGBA_NRGBA(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.NRGBA, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.PixOffset(sx0, sy0)
			pa := uint32(src.Pix[pi+3]) * 0x101
			pr := uint32(src.Pix[pi+0]) * pa / 0xff
			pg := uint32(src.Pix[pi+1]) * pa / 0xff
			pb := uint32(src.Pix[pi+2]) * pa / 0xff
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) transform_RGBA_RGBA(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.RGBA, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.PixOffset(sx0, sy0)
			pr := uint32(src.Pix[pi+0]) * 0x101
			pg := uint32(src.Pix[pi+1]) * 0x101
			pb := uint32(src.Pix[pi+2]) * 0x101
			pa := uint32(src.Pix[pi+3]) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) transform_RGBA_Uniform(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.Uniform, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pr, pg, pb, pa := src.At(sx0, sy0).RGBA()
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) transform_RGBA_YCbCr444(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.YOffset(sx0, sy0)
			pj := src.COffset(sx0, sy0)
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) transform_RGBA_YCbCr422(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.YOffset(sx0, sy0)
			pj := src.COffset(sx0, sy0)
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) transform_RGBA_YCbCr420(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.YOffset(sx0, sy0)
			pj := src.COffset(sx0, sy0)
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) transform_RGBA_YCbCr440(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pi := src.YOffset(sx0, sy0)
			pj := src.COffset(sx0, sy0)
			pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
			pr := uint32(pr8) * 0x101
			pg := uint32(pg8) * 0x101
			pb := uint32(pb8) * 0x101
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (nnInterpolator) transform_RGBA_Image(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src image.Image, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pr, pg, pb, pa := src.At(sx0, sy0).RGBA()
			dst.Pix[d+0] = uint8(uint32(pr) >> 8)
			dst.Pix[d+1] = uint8(uint32(pg) >> 8)
			dst.Pix[d+2] = uint8(uint32(pb) >> 8)
			dst.Pix[d+3] = uint8(uint32(pa) >> 8)
		}
	}
}

func (nnInterpolator) transform_Image_Image(dst Image, dr, adr image.Rectangle, d2s *f64.Aff3, src image.Image, sr image.Rectangle) {
	dstColorRGBA64 := &color.RGBA64{}
	dstColor := color.Color(dstColorRGBA64)
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx0 := int(math.Floor(d2s[0]*dxf + d2s[1]*dyf + d2s[2]))
			sy0 := int(math.Floor(d2s[3]*dxf + d2s[4]*dyf + d2s[5]))
			if !(image.Point{sx0, sy0}).In(sr) {
				continue
			}
			pr, pg, pb, pa := src.At(sx0, sy0).RGBA()
			dstColorRGBA64.R = uint16(pr)
			dstColorRGBA64.G = uint16(pg)
			dstColorRGBA64.B = uint16(pb)
			dstColorRGBA64.A = uint16(pa)
			dst.Set(dr.Min.X+int(dx), dr.Min.Y+int(dy), dstColor)
		}
	}
}

func (z ablInterpolator) Scale(dst Image, dr image.Rectangle, src image.Image, sr image.Rectangle, opts *Options) {
	// adr is the affected destination pixels, relative to dr.Min.
	adr := dst.Bounds().Intersect(dr).Sub(dr.Min)
	if adr.Empty() || sr.Empty() {
		return
	}
	// sr is the source pixels. If it extends beyond the src bounds,
	// we cannot use the type-specific fast paths, as they access
	// the Pix fields directly without bounds checking.
	if !sr.In(src.Bounds()) {
		z.scale_Image_Image(dst, dr, adr, src, sr)
	} else {
		switch dst := dst.(type) {
		case *image.RGBA:
			switch src := src.(type) {
			case *image.Gray:
				z.scale_RGBA_Gray(dst, dr, adr, src, sr)
			case *image.NRGBA:
				z.scale_RGBA_NRGBA(dst, dr, adr, src, sr)
			case *image.RGBA:
				z.scale_RGBA_RGBA(dst, dr, adr, src, sr)
			case *image.Uniform:
				z.scale_RGBA_Uniform(dst, dr, adr, src, sr)
			case *image.YCbCr:
				switch src.SubsampleRatio {
				default:
					z.scale_RGBA_Image(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio444:
					z.scale_RGBA_YCbCr444(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio422:
					z.scale_RGBA_YCbCr422(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio420:
					z.scale_RGBA_YCbCr420(dst, dr, adr, src, sr)
				case image.YCbCrSubsampleRatio440:
					z.scale_RGBA_YCbCr440(dst, dr, adr, src, sr)
				}
			default:
				z.scale_RGBA_Image(dst, dr, adr, src, sr)
			}
		default:
			switch src := src.(type) {
			default:
				z.scale_Image_Image(dst, dr, adr, src, sr)
			}
		}
	}
}

func (z ablInterpolator) Transform(dst Image, s2d *f64.Aff3, src image.Image, sr image.Rectangle, opts *Options) {
	dr := transformRect(s2d, &sr)
	// adr is the affected destination pixels, relative to dr.Min.
	adr := dst.Bounds().Intersect(dr).Sub(dr.Min)
	if adr.Empty() || sr.Empty() {
		return
	}
	d2s := invert(s2d)
	// sr is the source pixels. If it extends beyond the src bounds,
	// we cannot use the type-specific fast paths, as they access
	// the Pix fields directly without bounds checking.
	if !sr.In(src.Bounds()) {
		z.transform_Image_Image(dst, dr, adr, &d2s, src, sr)
	} else {
		switch dst := dst.(type) {
		case *image.RGBA:
			switch src := src.(type) {
			case *image.Gray:
				z.transform_RGBA_Gray(dst, dr, adr, &d2s, src, sr)
			case *image.NRGBA:
				z.transform_RGBA_NRGBA(dst, dr, adr, &d2s, src, sr)
			case *image.RGBA:
				z.transform_RGBA_RGBA(dst, dr, adr, &d2s, src, sr)
			case *image.Uniform:
				z.transform_RGBA_Uniform(dst, dr, adr, &d2s, src, sr)
			case *image.YCbCr:
				switch src.SubsampleRatio {
				default:
					z.transform_RGBA_Image(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio444:
					z.transform_RGBA_YCbCr444(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio422:
					z.transform_RGBA_YCbCr422(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio420:
					z.transform_RGBA_YCbCr420(dst, dr, adr, &d2s, src, sr)
				case image.YCbCrSubsampleRatio440:
					z.transform_RGBA_YCbCr440(dst, dr, adr, &d2s, src, sr)
				}
			default:
				z.transform_RGBA_Image(dst, dr, adr, &d2s, src, sr)
			}
		default:
			switch src := src.(type) {
			default:
				z.transform_Image_Image(dst, dr, adr, &d2s, src, sr)
			}
		}
	}
}

func (ablInterpolator) scale_RGBA_Gray(dst *image.RGBA, dr, adr image.Rectangle, src *image.Gray, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.PixOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00ru := uint32(src.Pix[s00i]) * 0x101
			s00r := float64(s00ru)
			s10i := src.PixOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10ru := uint32(src.Pix[s10i]) * 0x101
			s10r := float64(s10ru)
			s10r = xFrac1*s00r + xFrac0*s10r
			s01i := src.PixOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01ru := uint32(src.Pix[s01i]) * 0x101
			s01r := float64(s01ru)
			s11i := src.PixOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11ru := uint32(src.Pix[s11i]) * 0x101
			s11r := float64(s11ru)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11r = yFrac1*s10r + yFrac0*s11r
			out := uint8(uint32(s11r) >> 8)
			dst.Pix[d+0] = out
			dst.Pix[d+1] = out
			dst.Pix[d+2] = out
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) scale_RGBA_NRGBA(dst *image.RGBA, dr, adr image.Rectangle, src *image.NRGBA, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.PixOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00au := uint32(src.Pix[s00i+3]) * 0x101
			s00ru := uint32(src.Pix[s00i+0]) * s00au / 0xff
			s00gu := uint32(src.Pix[s00i+1]) * s00au / 0xff
			s00bu := uint32(src.Pix[s00i+2]) * s00au / 0xff
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10i := src.PixOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10au := uint32(src.Pix[s10i+3]) * 0x101
			s10ru := uint32(src.Pix[s10i+0]) * s10au / 0xff
			s10gu := uint32(src.Pix[s10i+1]) * s10au / 0xff
			s10bu := uint32(src.Pix[s10i+2]) * s10au / 0xff
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01i := src.PixOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01au := uint32(src.Pix[s01i+3]) * 0x101
			s01ru := uint32(src.Pix[s01i+0]) * s01au / 0xff
			s01gu := uint32(src.Pix[s01i+1]) * s01au / 0xff
			s01bu := uint32(src.Pix[s01i+2]) * s01au / 0xff
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11i := src.PixOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11au := uint32(src.Pix[s11i+3]) * 0x101
			s11ru := uint32(src.Pix[s11i+0]) * s11au / 0xff
			s11gu := uint32(src.Pix[s11i+1]) * s11au / 0xff
			s11bu := uint32(src.Pix[s11i+2]) * s11au / 0xff
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) scale_RGBA_RGBA(dst *image.RGBA, dr, adr image.Rectangle, src *image.RGBA, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.PixOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00ru := uint32(src.Pix[s00i+0]) * 0x101
			s00gu := uint32(src.Pix[s00i+1]) * 0x101
			s00bu := uint32(src.Pix[s00i+2]) * 0x101
			s00au := uint32(src.Pix[s00i+3]) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10i := src.PixOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10ru := uint32(src.Pix[s10i+0]) * 0x101
			s10gu := uint32(src.Pix[s10i+1]) * 0x101
			s10bu := uint32(src.Pix[s10i+2]) * 0x101
			s10au := uint32(src.Pix[s10i+3]) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01i := src.PixOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01ru := uint32(src.Pix[s01i+0]) * 0x101
			s01gu := uint32(src.Pix[s01i+1]) * 0x101
			s01bu := uint32(src.Pix[s01i+2]) * 0x101
			s01au := uint32(src.Pix[s01i+3]) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11i := src.PixOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11ru := uint32(src.Pix[s11i+0]) * 0x101
			s11gu := uint32(src.Pix[s11i+1]) * 0x101
			s11bu := uint32(src.Pix[s11i+2]) * 0x101
			s11au := uint32(src.Pix[s11i+3]) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) scale_RGBA_Uniform(dst *image.RGBA, dr, adr image.Rectangle, src *image.Uniform, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00ru, s00gu, s00bu, s00au := src.At(sr.Min.X+int(sx0), sr.Min.Y+int(sy0)).RGBA()
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10ru, s10gu, s10bu, s10au := src.At(sr.Min.X+int(sx1), sr.Min.Y+int(sy0)).RGBA()
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01ru, s01gu, s01bu, s01au := src.At(sr.Min.X+int(sx0), sr.Min.Y+int(sy1)).RGBA()
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11ru, s11gu, s11bu, s11au := src.At(sr.Min.X+int(sx1), sr.Min.Y+int(sy1)).RGBA()
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) scale_RGBA_YCbCr444(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) scale_RGBA_YCbCr422(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) scale_RGBA_YCbCr420(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) scale_RGBA_YCbCr440(dst *image.RGBA, dr, adr image.Rectangle, src *image.YCbCr, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy0))
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy0))
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01j := src.COffset(sr.Min.X+int(sx0), sr.Min.Y+int(sy1))
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11j := src.COffset(sr.Min.X+int(sx1), sr.Min.Y+int(sy1))
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) scale_RGBA_Image(dst *image.RGBA, dr, adr image.Rectangle, src image.Image, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00ru, s00gu, s00bu, s00au := src.At(sr.Min.X+int(sx0), sr.Min.Y+int(sy0)).RGBA()
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10ru, s10gu, s10bu, s10au := src.At(sr.Min.X+int(sx1), sr.Min.Y+int(sy0)).RGBA()
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01ru, s01gu, s01bu, s01au := src.At(sr.Min.X+int(sx0), sr.Min.Y+int(sy1)).RGBA()
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11ru, s11gu, s11bu, s11au := src.At(sr.Min.X+int(sx1), sr.Min.Y+int(sy1)).RGBA()
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) scale_Image_Image(dst Image, dr, adr image.Rectangle, src image.Image, sr image.Rectangle) {
	sw := int32(sr.Dx())
	sh := int32(sr.Dy())
	yscale := float64(sh) / float64(dr.Dy())
	xscale := float64(sw) / float64(dr.Dx())
	swMinus1, shMinus1 := sw-1, sh-1
	dstColorRGBA64 := &color.RGBA64{}
	dstColor := color.Color(dstColorRGBA64)

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		sy := (float64(dy)+0.5)*yscale - 0.5
		// If sy < 0, we will clamp sy0 to 0 anyway, so it doesn't matter if
		// we say int32(sy) instead of int32(math.Floor(sy)). Similarly for
		// sx, below.
		sy0 := int32(sy)
		yFrac0 := sy - float64(sy0)
		yFrac1 := 1 - yFrac0
		sy1 := sy0 + 1
		if sy < 0 {
			sy0, sy1 = 0, 0
			yFrac0, yFrac1 = 0, 1
		} else if sy1 > shMinus1 {
			sy0, sy1 = shMinus1, shMinus1
			yFrac0, yFrac1 = 1, 0
		}

		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
			sx := (float64(dx)+0.5)*xscale - 0.5
			sx0 := int32(sx)
			xFrac0 := sx - float64(sx0)
			xFrac1 := 1 - xFrac0
			sx1 := sx0 + 1
			if sx < 0 {
				sx0, sx1 = 0, 0
				xFrac0, xFrac1 = 0, 1
			} else if sx1 > swMinus1 {
				sx0, sx1 = swMinus1, swMinus1
				xFrac0, xFrac1 = 1, 0
			}

			s00ru, s00gu, s00bu, s00au := src.At(sr.Min.X+int(sx0), sr.Min.Y+int(sy0)).RGBA()
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10ru, s10gu, s10bu, s10au := src.At(sr.Min.X+int(sx1), sr.Min.Y+int(sy0)).RGBA()
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01ru, s01gu, s01bu, s01au := src.At(sr.Min.X+int(sx0), sr.Min.Y+int(sy1)).RGBA()
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11ru, s11gu, s11bu, s11au := src.At(sr.Min.X+int(sx1), sr.Min.Y+int(sy1)).RGBA()
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dstColorRGBA64.R = uint16(s11r)
			dstColorRGBA64.G = uint16(s11g)
			dstColorRGBA64.B = uint16(s11b)
			dstColorRGBA64.A = uint16(s11a)
			dst.Set(dr.Min.X+int(dx), dr.Min.Y+int(dy), dstColor)
		}
	}
}

func (ablInterpolator) transform_RGBA_Gray(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.Gray, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.PixOffset(sx0, sy0)
			s00ru := uint32(src.Pix[s00i]) * 0x101
			s00r := float64(s00ru)
			s10i := src.PixOffset(sx1, sy0)
			s10ru := uint32(src.Pix[s10i]) * 0x101
			s10r := float64(s10ru)
			s10r = xFrac1*s00r + xFrac0*s10r
			s01i := src.PixOffset(sx0, sy1)
			s01ru := uint32(src.Pix[s01i]) * 0x101
			s01r := float64(s01ru)
			s11i := src.PixOffset(sx1, sy1)
			s11ru := uint32(src.Pix[s11i]) * 0x101
			s11r := float64(s11ru)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11r = yFrac1*s10r + yFrac0*s11r
			out := uint8(uint32(s11r) >> 8)
			dst.Pix[d+0] = out
			dst.Pix[d+1] = out
			dst.Pix[d+2] = out
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) transform_RGBA_NRGBA(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.NRGBA, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.PixOffset(sx0, sy0)
			s00au := uint32(src.Pix[s00i+3]) * 0x101
			s00ru := uint32(src.Pix[s00i+0]) * s00au / 0xff
			s00gu := uint32(src.Pix[s00i+1]) * s00au / 0xff
			s00bu := uint32(src.Pix[s00i+2]) * s00au / 0xff
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10i := src.PixOffset(sx1, sy0)
			s10au := uint32(src.Pix[s10i+3]) * 0x101
			s10ru := uint32(src.Pix[s10i+0]) * s10au / 0xff
			s10gu := uint32(src.Pix[s10i+1]) * s10au / 0xff
			s10bu := uint32(src.Pix[s10i+2]) * s10au / 0xff
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01i := src.PixOffset(sx0, sy1)
			s01au := uint32(src.Pix[s01i+3]) * 0x101
			s01ru := uint32(src.Pix[s01i+0]) * s01au / 0xff
			s01gu := uint32(src.Pix[s01i+1]) * s01au / 0xff
			s01bu := uint32(src.Pix[s01i+2]) * s01au / 0xff
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11i := src.PixOffset(sx1, sy1)
			s11au := uint32(src.Pix[s11i+3]) * 0x101
			s11ru := uint32(src.Pix[s11i+0]) * s11au / 0xff
			s11gu := uint32(src.Pix[s11i+1]) * s11au / 0xff
			s11bu := uint32(src.Pix[s11i+2]) * s11au / 0xff
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) transform_RGBA_RGBA(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.RGBA, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.PixOffset(sx0, sy0)
			s00ru := uint32(src.Pix[s00i+0]) * 0x101
			s00gu := uint32(src.Pix[s00i+1]) * 0x101
			s00bu := uint32(src.Pix[s00i+2]) * 0x101
			s00au := uint32(src.Pix[s00i+3]) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10i := src.PixOffset(sx1, sy0)
			s10ru := uint32(src.Pix[s10i+0]) * 0x101
			s10gu := uint32(src.Pix[s10i+1]) * 0x101
			s10bu := uint32(src.Pix[s10i+2]) * 0x101
			s10au := uint32(src.Pix[s10i+3]) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01i := src.PixOffset(sx0, sy1)
			s01ru := uint32(src.Pix[s01i+0]) * 0x101
			s01gu := uint32(src.Pix[s01i+1]) * 0x101
			s01bu := uint32(src.Pix[s01i+2]) * 0x101
			s01au := uint32(src.Pix[s01i+3]) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11i := src.PixOffset(sx1, sy1)
			s11ru := uint32(src.Pix[s11i+0]) * 0x101
			s11gu := uint32(src.Pix[s11i+1]) * 0x101
			s11bu := uint32(src.Pix[s11i+2]) * 0x101
			s11au := uint32(src.Pix[s11i+3]) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) transform_RGBA_Uniform(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.Uniform, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00ru, s00gu, s00bu, s00au := src.At(sx0, sy0).RGBA()
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10ru, s10gu, s10bu, s10au := src.At(sx1, sy0).RGBA()
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01ru, s01gu, s01bu, s01au := src.At(sx0, sy1).RGBA()
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11ru, s11gu, s11bu, s11au := src.At(sx1, sy1).RGBA()
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) transform_RGBA_YCbCr444(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.YOffset(sx0, sy0)
			s00j := src.COffset(sx0, sy0)
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sx1, sy0)
			s10j := src.COffset(sx1, sy0)
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sx0, sy1)
			s01j := src.COffset(sx0, sy1)
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sx1, sy1)
			s11j := src.COffset(sx1, sy1)
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) transform_RGBA_YCbCr422(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.YOffset(sx0, sy0)
			s00j := src.COffset(sx0, sy0)
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sx1, sy0)
			s10j := src.COffset(sx1, sy0)
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sx0, sy1)
			s01j := src.COffset(sx0, sy1)
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sx1, sy1)
			s11j := src.COffset(sx1, sy1)
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) transform_RGBA_YCbCr420(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.YOffset(sx0, sy0)
			s00j := src.COffset(sx0, sy0)
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sx1, sy0)
			s10j := src.COffset(sx1, sy0)
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sx0, sy1)
			s01j := src.COffset(sx0, sy1)
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sx1, sy1)
			s11j := src.COffset(sx1, sy1)
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) transform_RGBA_YCbCr440(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00i := src.YOffset(sx0, sy0)
			s00j := src.COffset(sx0, sy0)
			s00r8, s00g8, s00b8 := color.YCbCrToRGB(src.Y[s00i], src.Cb[s00j], src.Cr[s00j])
			s00ru := uint32(s00r8) * 0x101
			s00gu := uint32(s00g8) * 0x101
			s00bu := uint32(s00b8) * 0x101
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s10i := src.YOffset(sx1, sy0)
			s10j := src.COffset(sx1, sy0)
			s10r8, s10g8, s10b8 := color.YCbCrToRGB(src.Y[s10i], src.Cb[s10j], src.Cr[s10j])
			s10ru := uint32(s10r8) * 0x101
			s10gu := uint32(s10g8) * 0x101
			s10bu := uint32(s10b8) * 0x101
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s01i := src.YOffset(sx0, sy1)
			s01j := src.COffset(sx0, sy1)
			s01r8, s01g8, s01b8 := color.YCbCrToRGB(src.Y[s01i], src.Cb[s01j], src.Cr[s01j])
			s01ru := uint32(s01r8) * 0x101
			s01gu := uint32(s01g8) * 0x101
			s01bu := uint32(s01b8) * 0x101
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s11i := src.YOffset(sx1, sy1)
			s11j := src.COffset(sx1, sy1)
			s11r8, s11g8, s11b8 := color.YCbCrToRGB(src.Y[s11i], src.Cb[s11j], src.Cr[s11j])
			s11ru := uint32(s11r8) * 0x101
			s11gu := uint32(s11g8) * 0x101
			s11bu := uint32(s11b8) * 0x101
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (ablInterpolator) transform_RGBA_Image(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src image.Image, sr image.Rectangle) {
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00ru, s00gu, s00bu, s00au := src.At(sx0, sy0).RGBA()
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10ru, s10gu, s10bu, s10au := src.At(sx1, sy0).RGBA()
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01ru, s01gu, s01bu, s01au := src.At(sx0, sy1).RGBA()
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11ru, s11gu, s11bu, s11au := src.At(sx1, sy1).RGBA()
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dst.Pix[d+0] = uint8(uint32(s11r) >> 8)
			dst.Pix[d+1] = uint8(uint32(s11g) >> 8)
			dst.Pix[d+2] = uint8(uint32(s11b) >> 8)
			dst.Pix[d+3] = uint8(uint32(s11a) >> 8)
		}
	}
}

func (ablInterpolator) transform_Image_Image(dst Image, dr, adr image.Rectangle, d2s *f64.Aff3, src image.Image, sr image.Rectangle) {
	dstColorRGBA64 := &color.RGBA64{}
	dstColor := color.Color(dstColorRGBA64)
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			sxf := math.Floor(sx)
			xFrac0 := sx - sxf
			xFrac1 := 1 - xFrac0
			sx0 := int(sxf)
			sx1 := sx0 + 1
			if sx0 < sr.Min.X {
				sx0, sx1 = sr.Min.X, sr.Min.X
				xFrac0, xFrac1 = 0, 1
			} else if sx1 >= sr.Max.X {
				sx0, sx1 = sr.Max.X-1, sr.Max.X-1
				xFrac0, xFrac1 = 1, 0
			}

			sy -= 0.5
			syf := math.Floor(sy)
			yFrac0 := sy - syf
			yFrac1 := 1 - yFrac0
			sy0 := int(syf)
			sy1 := sy0 + 1
			if sy0 < sr.Min.Y {
				sy0, sy1 = sr.Min.Y, sr.Min.Y
				yFrac0, yFrac1 = 0, 1
			} else if sy1 >= sr.Max.Y {
				sy0, sy1 = sr.Max.Y-1, sr.Max.Y-1
				yFrac0, yFrac1 = 1, 0
			}

			s00ru, s00gu, s00bu, s00au := src.At(sx0, sy0).RGBA()
			s00r := float64(s00ru)
			s00g := float64(s00gu)
			s00b := float64(s00bu)
			s00a := float64(s00au)
			s10ru, s10gu, s10bu, s10au := src.At(sx1, sy0).RGBA()
			s10r := float64(s10ru)
			s10g := float64(s10gu)
			s10b := float64(s10bu)
			s10a := float64(s10au)
			s10r = xFrac1*s00r + xFrac0*s10r
			s10g = xFrac1*s00g + xFrac0*s10g
			s10b = xFrac1*s00b + xFrac0*s10b
			s10a = xFrac1*s00a + xFrac0*s10a
			s01ru, s01gu, s01bu, s01au := src.At(sx0, sy1).RGBA()
			s01r := float64(s01ru)
			s01g := float64(s01gu)
			s01b := float64(s01bu)
			s01a := float64(s01au)
			s11ru, s11gu, s11bu, s11au := src.At(sx1, sy1).RGBA()
			s11r := float64(s11ru)
			s11g := float64(s11gu)
			s11b := float64(s11bu)
			s11a := float64(s11au)
			s11r = xFrac1*s01r + xFrac0*s11r
			s11g = xFrac1*s01g + xFrac0*s11g
			s11b = xFrac1*s01b + xFrac0*s11b
			s11a = xFrac1*s01a + xFrac0*s11a
			s11r = yFrac1*s10r + yFrac0*s11r
			s11g = yFrac1*s10g + yFrac0*s11g
			s11b = yFrac1*s10b + yFrac0*s11b
			s11a = yFrac1*s10a + yFrac0*s11a
			dstColorRGBA64.R = uint16(s11r)
			dstColorRGBA64.G = uint16(s11g)
			dstColorRGBA64.B = uint16(s11b)
			dstColorRGBA64.A = uint16(s11a)
			dst.Set(dr.Min.X+int(dx), dr.Min.Y+int(dy), dstColor)
		}
	}
}

func (z *kernelScaler) Scale(dst Image, dr image.Rectangle, src image.Image, sr image.Rectangle, opts *Options) {
	if z.dw != int32(dr.Dx()) || z.dh != int32(dr.Dy()) || z.sw != int32(sr.Dx()) || z.sh != int32(sr.Dy()) {
		z.kernel.Scale(dst, dr, src, sr, opts)
		return
	}
	// adr is the affected destination pixels, relative to dr.Min.
	adr := dst.Bounds().Intersect(dr).Sub(dr.Min)
	if adr.Empty() || sr.Empty() {
		return
	}
	// Create a temporary buffer:
	// scaleX distributes the source image's columns over the temporary image.
	// scaleY distributes the temporary image's rows over the destination image.
	// TODO: is it worth having a sync.Pool for this temporary buffer?
	tmp := make([][4]float64, z.dw*z.sh)

	// sr is the source pixels. If it extends beyond the src bounds,
	// we cannot use the type-specific fast paths, as they access
	// the Pix fields directly without bounds checking.
	if !sr.In(src.Bounds()) {
		z.scaleX_Image(tmp, src, sr)
	} else {
		switch src := src.(type) {
		case *image.Gray:
			z.scaleX_Gray(tmp, src, sr)
		case *image.NRGBA:
			z.scaleX_NRGBA(tmp, src, sr)
		case *image.RGBA:
			z.scaleX_RGBA(tmp, src, sr)
		case *image.Uniform:
			z.scaleX_Uniform(tmp, src, sr)
		case *image.YCbCr:
			switch src.SubsampleRatio {
			default:
				z.scaleX_Image(tmp, src, sr)
			case image.YCbCrSubsampleRatio444:
				z.scaleX_YCbCr444(tmp, src, sr)
			case image.YCbCrSubsampleRatio422:
				z.scaleX_YCbCr422(tmp, src, sr)
			case image.YCbCrSubsampleRatio420:
				z.scaleX_YCbCr420(tmp, src, sr)
			case image.YCbCrSubsampleRatio440:
				z.scaleX_YCbCr440(tmp, src, sr)
			}
		default:
			z.scaleX_Image(tmp, src, sr)
		}
	}

	switch dst := dst.(type) {
	case *image.RGBA:
		z.scaleY_RGBA(dst, dr, adr, tmp)
	default:
		z.scaleY_Image(dst, dr, adr, tmp)
	}
}

func (q *Kernel) Transform(dst Image, s2d *f64.Aff3, src image.Image, sr image.Rectangle, opts *Options) {
	dr := transformRect(s2d, &sr)
	// adr is the affected destination pixels, relative to dr.Min.
	adr := dst.Bounds().Intersect(dr).Sub(dr.Min)
	if adr.Empty() || sr.Empty() {
		return
	}
	d2s := invert(s2d)

	xscale := abs(d2s[0])
	if s := abs(d2s[1]); xscale < s {
		xscale = s
	}
	yscale := abs(d2s[3])
	if s := abs(d2s[4]); yscale < s {
		yscale = s
	}

	// sr is the source pixels. If it extends beyond the src bounds,
	// we cannot use the type-specific fast paths, as they access
	// the Pix fields directly without bounds checking.
	if !sr.In(src.Bounds()) {
		q.transform_Image_Image(dst, dr, adr, &d2s, src, sr, xscale, yscale)
	} else {
		switch dst := dst.(type) {
		case *image.RGBA:
			switch src := src.(type) {
			case *image.Gray:
				q.transform_RGBA_Gray(dst, dr, adr, &d2s, src, sr, xscale, yscale)
			case *image.NRGBA:
				q.transform_RGBA_NRGBA(dst, dr, adr, &d2s, src, sr, xscale, yscale)
			case *image.RGBA:
				q.transform_RGBA_RGBA(dst, dr, adr, &d2s, src, sr, xscale, yscale)
			case *image.Uniform:
				q.transform_RGBA_Uniform(dst, dr, adr, &d2s, src, sr, xscale, yscale)
			case *image.YCbCr:
				switch src.SubsampleRatio {
				default:
					q.transform_RGBA_Image(dst, dr, adr, &d2s, src, sr, xscale, yscale)
				case image.YCbCrSubsampleRatio444:
					q.transform_RGBA_YCbCr444(dst, dr, adr, &d2s, src, sr, xscale, yscale)
				case image.YCbCrSubsampleRatio422:
					q.transform_RGBA_YCbCr422(dst, dr, adr, &d2s, src, sr, xscale, yscale)
				case image.YCbCrSubsampleRatio420:
					q.transform_RGBA_YCbCr420(dst, dr, adr, &d2s, src, sr, xscale, yscale)
				case image.YCbCrSubsampleRatio440:
					q.transform_RGBA_YCbCr440(dst, dr, adr, &d2s, src, sr, xscale, yscale)
				}
			default:
				q.transform_RGBA_Image(dst, dr, adr, &d2s, src, sr, xscale, yscale)
			}
		default:
			switch src := src.(type) {
			default:
				q.transform_Image_Image(dst, dr, adr, &d2s, src, sr, xscale, yscale)
			}
		}
	}
}

func (z *kernelScaler) scaleX_Gray(tmp [][4]float64, src *image.Gray, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.PixOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pru := uint32(src.Pix[pi]) * 0x101
				pr += float64(pru) * c.weight
			}
			pr *= s.invTotalWeightFFFF
			tmp[t] = [4]float64{
				pr,
				pr,
				pr,
				1,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_NRGBA(tmp [][4]float64, src *image.NRGBA, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb, pa float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.PixOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pau := uint32(src.Pix[pi+3]) * 0x101
				pru := uint32(src.Pix[pi+0]) * pau / 0xff
				pgu := uint32(src.Pix[pi+1]) * pau / 0xff
				pbu := uint32(src.Pix[pi+2]) * pau / 0xff
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
				pa += float64(pau) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				pa * s.invTotalWeightFFFF,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_RGBA(tmp [][4]float64, src *image.RGBA, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb, pa float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.PixOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pru := uint32(src.Pix[pi+0]) * 0x101
				pgu := uint32(src.Pix[pi+1]) * 0x101
				pbu := uint32(src.Pix[pi+2]) * 0x101
				pau := uint32(src.Pix[pi+3]) * 0x101
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
				pa += float64(pau) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				pa * s.invTotalWeightFFFF,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_Uniform(tmp [][4]float64, src *image.Uniform, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb, pa float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pru, pgu, pbu, pau := src.At(sr.Min.X+int(c.coord), sr.Min.Y+int(y)).RGBA()
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
				pa += float64(pau) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				pa * s.invTotalWeightFFFF,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_YCbCr444(tmp [][4]float64, src *image.YCbCr, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.YOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pj := src.COffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
				pru := uint32(pr8) * 0x101
				pgu := uint32(pg8) * 0x101
				pbu := uint32(pb8) * 0x101
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				1,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_YCbCr422(tmp [][4]float64, src *image.YCbCr, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.YOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pj := src.COffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
				pru := uint32(pr8) * 0x101
				pgu := uint32(pg8) * 0x101
				pbu := uint32(pb8) * 0x101
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				1,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_YCbCr420(tmp [][4]float64, src *image.YCbCr, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.YOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pj := src.COffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
				pru := uint32(pr8) * 0x101
				pgu := uint32(pg8) * 0x101
				pbu := uint32(pb8) * 0x101
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				1,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_YCbCr440(tmp [][4]float64, src *image.YCbCr, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pi := src.YOffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pj := src.COffset(sr.Min.X+int(c.coord), sr.Min.Y+int(y))
				pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
				pru := uint32(pr8) * 0x101
				pgu := uint32(pg8) * 0x101
				pbu := uint32(pb8) * 0x101
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				1,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleX_Image(tmp [][4]float64, src image.Image, sr image.Rectangle) {
	t := 0
	for y := int32(0); y < z.sh; y++ {
		for _, s := range z.horizontal.sources {
			var pr, pg, pb, pa float64
			for _, c := range z.horizontal.contribs[s.i:s.j] {
				pru, pgu, pbu, pau := src.At(sr.Min.X+int(c.coord), sr.Min.Y+int(y)).RGBA()
				pr += float64(pru) * c.weight
				pg += float64(pgu) * c.weight
				pb += float64(pbu) * c.weight
				pa += float64(pau) * c.weight
			}
			tmp[t] = [4]float64{
				pr * s.invTotalWeightFFFF,
				pg * s.invTotalWeightFFFF,
				pb * s.invTotalWeightFFFF,
				pa * s.invTotalWeightFFFF,
			}
			t++
		}
	}
}

func (z *kernelScaler) scaleY_RGBA(dst *image.RGBA, dr, adr image.Rectangle, tmp [][4]float64) {
	for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
		d := dst.PixOffset(dr.Min.X+int(dx), dr.Min.Y+adr.Min.Y)
		for _, s := range z.vertical.sources[adr.Min.Y:adr.Max.Y] {
			var pr, pg, pb, pa float64
			for _, c := range z.vertical.contribs[s.i:s.j] {
				p := &tmp[c.coord*z.dw+dx]
				pr += p[0] * c.weight
				pg += p[1] * c.weight
				pb += p[2] * c.weight
				pa += p[3] * c.weight
			}
			dst.Pix[d+0] = uint8(ftou(pr*s.invTotalWeight) >> 8)
			dst.Pix[d+1] = uint8(ftou(pg*s.invTotalWeight) >> 8)
			dst.Pix[d+2] = uint8(ftou(pb*s.invTotalWeight) >> 8)
			dst.Pix[d+3] = uint8(ftou(pa*s.invTotalWeight) >> 8)
			d += dst.Stride
		}
	}
}

func (z *kernelScaler) scaleY_Image(dst Image, dr, adr image.Rectangle, tmp [][4]float64) {
	dstColorRGBA64 := &color.RGBA64{}
	dstColor := color.Color(dstColorRGBA64)
	for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
		for dy, s := range z.vertical.sources[adr.Min.Y:adr.Max.Y] {
			var pr, pg, pb, pa float64
			for _, c := range z.vertical.contribs[s.i:s.j] {
				p := &tmp[c.coord*z.dw+dx]
				pr += p[0] * c.weight
				pg += p[1] * c.weight
				pb += p[2] * c.weight
				pa += p[3] * c.weight
			}
			dstColorRGBA64.R = ftou(pr * s.invTotalWeight)
			dstColorRGBA64.G = ftou(pg * s.invTotalWeight)
			dstColorRGBA64.B = ftou(pb * s.invTotalWeight)
			dstColorRGBA64.A = ftou(pa * s.invTotalWeight)
			dst.Set(dr.Min.X+int(dx), dr.Min.Y+int(adr.Min.Y+dy), dstColor)
		}
	}
}

func (q *Kernel) transform_RGBA_Gray(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.Gray, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.PixOffset(kx, ky)
					pru := uint32(src.Pix[pi]) * 0x101
					pr += float64(pru) * w
				}
			}
			out := uint8(fffftou(pr) >> 8)
			dst.Pix[d+0] = out
			dst.Pix[d+1] = out
			dst.Pix[d+2] = out
			dst.Pix[d+3] = 0xff
		}
	}
}

func (q *Kernel) transform_RGBA_NRGBA(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.NRGBA, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb, pa float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.PixOffset(kx, ky)
					pau := uint32(src.Pix[pi+3]) * 0x101
					pru := uint32(src.Pix[pi+0]) * pau / 0xff
					pgu := uint32(src.Pix[pi+1]) * pau / 0xff
					pbu := uint32(src.Pix[pi+2]) * pau / 0xff
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
					pa += float64(pau) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = uint8(fffftou(pa) >> 8)
		}
	}
}

func (q *Kernel) transform_RGBA_RGBA(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.RGBA, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb, pa float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.PixOffset(kx, ky)
					pru := uint32(src.Pix[pi+0]) * 0x101
					pgu := uint32(src.Pix[pi+1]) * 0x101
					pbu := uint32(src.Pix[pi+2]) * 0x101
					pau := uint32(src.Pix[pi+3]) * 0x101
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
					pa += float64(pau) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = uint8(fffftou(pa) >> 8)
		}
	}
}

func (q *Kernel) transform_RGBA_Uniform(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.Uniform, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb, pa float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pru, pgu, pbu, pau := src.At(kx, ky).RGBA()
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
					pa += float64(pau) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = uint8(fffftou(pa) >> 8)
		}
	}
}

func (q *Kernel) transform_RGBA_YCbCr444(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.YOffset(kx, ky)
					pj := src.COffset(kx, ky)
					pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
					pru := uint32(pr8) * 0x101
					pgu := uint32(pg8) * 0x101
					pbu := uint32(pb8) * 0x101
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (q *Kernel) transform_RGBA_YCbCr422(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.YOffset(kx, ky)
					pj := src.COffset(kx, ky)
					pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
					pru := uint32(pr8) * 0x101
					pgu := uint32(pg8) * 0x101
					pbu := uint32(pb8) * 0x101
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (q *Kernel) transform_RGBA_YCbCr420(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.YOffset(kx, ky)
					pj := src.COffset(kx, ky)
					pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
					pru := uint32(pr8) * 0x101
					pgu := uint32(pg8) * 0x101
					pbu := uint32(pb8) * 0x101
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (q *Kernel) transform_RGBA_YCbCr440(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src *image.YCbCr, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pi := src.YOffset(kx, ky)
					pj := src.COffset(kx, ky)
					pr8, pg8, pb8 := color.YCbCrToRGB(src.Y[pi], src.Cb[pj], src.Cr[pj])
					pru := uint32(pr8) * 0x101
					pgu := uint32(pg8) * 0x101
					pbu := uint32(pb8) * 0x101
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = 0xff
		}
	}
}

func (q *Kernel) transform_RGBA_Image(dst *image.RGBA, dr, adr image.Rectangle, d2s *f64.Aff3, src image.Image, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		d := dst.PixOffset(dr.Min.X+adr.Min.X, dr.Min.Y+int(dy))
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx, d = dx+1, d+4 {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb, pa float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pru, pgu, pbu, pau := src.At(kx, ky).RGBA()
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
					pa += float64(pau) * w
				}
			}
			dst.Pix[d+0] = uint8(fffftou(pr) >> 8)
			dst.Pix[d+1] = uint8(fffftou(pg) >> 8)
			dst.Pix[d+2] = uint8(fffftou(pb) >> 8)
			dst.Pix[d+3] = uint8(fffftou(pa) >> 8)
		}
	}
}

func (q *Kernel) transform_Image_Image(dst Image, dr, adr image.Rectangle, d2s *f64.Aff3, src image.Image, sr image.Rectangle, xscale, yscale float64) {
	// When shrinking, broaden the effective kernel support so that we still
	// visit every source pixel.
	xHalfWidth, xKernelArgScale := q.Support, 1.0
	if xscale > 1 {
		xHalfWidth *= xscale
		xKernelArgScale = 1 / xscale
	}
	yHalfWidth, yKernelArgScale := q.Support, 1.0
	if yscale > 1 {
		yHalfWidth *= yscale
		yKernelArgScale = 1 / yscale
	}

	xWeights := make([]float64, 1+2*int(math.Ceil(xHalfWidth)))
	yWeights := make([]float64, 1+2*int(math.Ceil(yHalfWidth)))

	dstColorRGBA64 := &color.RGBA64{}
	dstColor := color.Color(dstColorRGBA64)
	for dy := int32(adr.Min.Y); dy < int32(adr.Max.Y); dy++ {
		dyf := float64(dr.Min.Y+int(dy)) + 0.5
		for dx := int32(adr.Min.X); dx < int32(adr.Max.X); dx++ {
			dxf := float64(dr.Min.X+int(dx)) + 0.5
			// TODO: change the src origin so that we can say int(f) instead of int(math.Floor(f)).
			sx := d2s[0]*dxf + d2s[1]*dyf + d2s[2]
			sy := d2s[3]*dxf + d2s[4]*dyf + d2s[5]
			if !(image.Point{int(math.Floor(sx)), int(math.Floor(sy))}).In(sr) {
				continue
			}

			sx -= 0.5
			ix := int(math.Floor(sx - xHalfWidth))
			if ix < sr.Min.X {
				ix = sr.Min.X
			}
			jx := int(math.Ceil(sx + xHalfWidth))
			if jx > sr.Max.X {
				jx = sr.Max.X
			}

			totalXWeight := 0.0
			for kx := ix; kx < jx; kx++ {
				xWeight := 0.0
				if t := abs((sx - float64(kx)) * xKernelArgScale); t < q.Support {
					xWeight = q.At(t)
				}
				xWeights[kx-ix] = xWeight
				totalXWeight += xWeight
			}
			for x := range xWeights[:jx-ix] {
				xWeights[x] /= totalXWeight
			}

			sy -= 0.5
			iy := int(math.Floor(sy - yHalfWidth))
			if iy < sr.Min.Y {
				iy = sr.Min.Y
			}
			jy := int(math.Ceil(sy + yHalfWidth))
			if jy > sr.Max.Y {
				jy = sr.Max.Y
			}

			totalYWeight := 0.0
			for ky := iy; ky < jy; ky++ {
				yWeight := 0.0
				if t := abs((sy - float64(ky)) * yKernelArgScale); t < q.Support {
					yWeight = q.At(t)
				}
				yWeights[ky-iy] = yWeight
				totalYWeight += yWeight
			}
			for y := range yWeights[:jy-iy] {
				yWeights[y] /= totalYWeight
			}

			var pr, pg, pb, pa float64
			for ky := iy; ky < jy; ky++ {
				yWeight := yWeights[ky-iy]
				for kx := ix; kx < jx; kx++ {
					w := xWeights[kx-ix] * yWeight
					pru, pgu, pbu, pau := src.At(kx, ky).RGBA()
					pr += float64(pru) * w
					pg += float64(pgu) * w
					pb += float64(pbu) * w
					pa += float64(pau) * w
				}
			}
			dstColorRGBA64.R = fffftou(pr)
			dstColorRGBA64.G = fffftou(pg)
			dstColorRGBA64.B = fffftou(pb)
			dstColorRGBA64.A = fffftou(pa)
			dst.Set(dr.Min.X+int(dx), dr.Min.Y+int(dy), dstColor)
		}
	}
}
